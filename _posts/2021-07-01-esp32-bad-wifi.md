---
title: Enabling malicious WiFi frames in the esp32 SDK
hero_image: /assets/images/2021-07-01-esp32-bad-wifi/esp32.jpg
image: /assets/images/2021-07-01-esp32-bad-wifi/esp32.jpg
description: How to enable malicious WiFi frames in the esp32 SDK
tags: cybersecurity reverse-engineering embedded-systems
summary: How to enable malicious WiFi frames in the esp32 SDK
---
# Bypassing frame type restrictions in the ESP32's WiFi library to allow deauthentication frames among others

###### NB: This was done in 2021, I haven't messed with the esp-sdk since then. Shall do soon
![unsupported frame type](/assets/images/2021-07-01-esp32-bad-wifi/unsupport_frame_type_c0.jpg)



It is well known that the ESP32's WiFi library contains restrictions regarding some potentially malicious frames.
This restriction is software based which means that it is relatively easy to bypass.

Espressif provides tools and libraries under the Apache 2.0 license, some of the internals however are only provided as object files or libraries.

No advandced knowledge of xtensa instruction set is required, but the Xtensa Instruction Set Architecture (ISA) Reference Manual is of great help.
In this case we want to enable deauthentication frames, but the same process can be used to enable other restricted types.
This will show how this is done.

## Table of Contents

1. [Setup](#setup)
2. [Disabling the restriction](#disabling-the-restriction)
3. [Patching the library](#patching-the-library)


## Setup

All we need is an ESP32 board and the ESP-IDF toolset (which includes disassembler, compiler, debugger, etc).
I use radare2 to disassemble the binary but you can use the provided tools to dig into the binary (esp-idf installs them in the .espressif folder in your home directory by default).

We start with compiling a basic application with the bare minimum configurations needed that periodically sends deauth frames.
We use *esp_wifi_80211_tx* function to send those.

If you want to do this the dynamic way (with a debugger) you would have to setup a debugging interface first, a [Rasberry PI with openOCD](https://github.com/espressif/openocd-esp32) is enough.
The process is simple but disassembling and using the Xtensa ISA reference manual is faster as the restriction is trivial.

## Disabling the restriction

Disassembling *esp_wifi_80211_tx* shows a call to a function with an interesting name : *ieee80211_raw_frame_sanity_check*

![ieee80211_raw_frame_sanity_check](/assets/images/2021-07-01-esp32-bad-wifi/ieee80211_raw_frame_sanity_check.jpg)



Or we can also directly search for the error message's string within the binary and dig from there.
![string search](/assets/images/2021-07-01-esp32-bad-wifi/string_search.jpg)



Disassembling the instruction block involving the error message (string address loaded into a13 in 0x401038a7) shows a call to *wifi_log* (shortly before a retw.n).
![instruction blocks](/assets/images/2021-07-01-esp32-bad-wifi/instruction_blk1.jpg)



Knowing how arguments are passed we take a look at the values loaded in the a10+ registers:
![calln](/assets/images/2021-07-01-esp32-bad-wifi/calln.jpg)



The a13 register is loaded with the address of our error message, which means it's the 4th argument to *wifi_log*.
![l32r](/assets/images/2021-07-01-esp32-bad-wifi/l32r.jpg)
###### *Xtensa ISA Reference Manual*


Looking at the visual graph we can see that 2 branches lead to the 0x401038a5 block, they are most likely the ones determining whether the frame will be sent or the error message will be dislayed:

![branch](/assets/images/2021-07-01-esp32-bad-wifi/branch.jpg)



In this case we would want the conditional bnez.n (narrow branch if not equal to zero) to be replaced with an instruction that does nothing (nop) so that it never branches into 0x401038a5, as for beq (branch if equal), we would want it to be replaced by a j (jump) as 0x401038a5 is the next instruction address.
The instructions need to have the same size, bnez.n is 2 bytes long therefore it will be replaced with nop.n (the 2 bytes long version of nop), beq is 3 bytes long and so is j.

The opcode for nop.n is 0xf03d, we first have to calculate the offset for j:

![xtensa jump instruction](/assets/images/2021-07-01-esp32-bad-wifi/xtensa_jump_instruction.jpg)
###### *Xtensa ISA Reference Manual*



We need to jump to 0x401083b1 while PC is pointing to 0x401038a5 (next instruction address) we need an offset of 0xB (an offset of 0 is a jump of 1 byte, 0xb1-0xa5-1 = 0xB), therefore our opcode will be: 0x0002c6

![changing instruction](/assets/images/2021-07-01-esp32-bad-wifi/changing_instruction.jpg)
##### *(big endian)*



After flashing the ESP32 with our new binary, no error message is displayed anymore and we can check that they the frames are indeed being transmitted:

![0c0 is supported](/assets/images/2021-07-01-esp32-bad-wifi/0c0_supported.jpg)
###### *Xtensa ISA Reference Manual*



![wireshark](/assets/images/2021-07-01-esp32-bad-wifi/wireshark.jpg)
###### *Frames captured by another device*



One fast way to bypass the restriction could then be just redefining *ieee80211_raw_frame_sanity_check* as a dummy function as some do, however this would remove all the other potentially useful checking this function does.

We can now patch our binaries before flashing them, this however would have to be done after every compilation (can be automated).

There is however another more convenient way of doing it: patching the library itself.

## Patching the library  

First we need to extract the object files from the libnet80211.a library (esp-idf/components/esp_wifi/lib/esp32/libnet80211.a) :
ieee80211_output.o is the one we need to patch as it is the one containing *ieee80211_raw_frame_sanity_check*.
The process is almost the same as patching the binary, except that we are dealing with an unlinked object file: finding those instructions that need to be changed will be slightly different, we can just use the visual graph or calculate the offset from the function's first instruction.

All there is to do is then reassemble the library with ar and replace the old one.

WIP
